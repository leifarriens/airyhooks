/**
 * This script reads hook source files from src/ and generates
 * a templates file for the CLI package.
 *
 * Run with: pnpm build:templates
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const HOOKS_SRC_DIR = path.resolve(__dirname, "../src");
const CLI_OUTPUT_PATH = path.resolve(
  __dirname,
  "../../cli/src/utils/hook-templates.ts",
);

interface HookTemplate {
  content: string;
  name: string;
  test: string;
}

/**
 * Extract exported function names from a TypeScript file content.
 * Uses a Set to deduplicate names (handles function overloads).
 */
function extractExportedFunctions(content: string): string[] {
  const exportRegex = /export\s+function\s+(\w+)/g;
  const matches = new Set<string>();
  let match: RegExpExecArray | null;

  while ((match = exportRegex.exec(content)) !== null) {
    if (match[1]) {
      matches.add(match[1]);
    }
  }

  return [...matches];
}

/**
 * Read all hook source files and extract templates.
 */
function readHookTemplates(): HookTemplate[] {
  const templates: HookTemplate[] = [];
  const hookDirs = fs
    .readdirSync(HOOKS_SRC_DIR, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory() && dirent.name.startsWith("use"))
    .map((dirent) => dirent.name);

  for (const hookDir of hookDirs) {
    const hookFile = path.join(HOOKS_SRC_DIR, hookDir, `${hookDir}.ts`);
    const hookTestFile = path.join(
      HOOKS_SRC_DIR,
      hookDir,
      `${hookDir}.test.ts`,
    );

    if (!fs.existsSync(hookFile)) {
      console.warn(`Warning: Expected file not found: ${hookFile}`);
      continue;
    }

    if (!fs.existsSync(hookTestFile)) {
      console.warn(`Warning: Expected test file not found: ${hookTestFile}`);
      continue;
    }

    const content = fs.readFileSync(hookFile, "utf-8");
    const exportedFunctions = extractExportedFunctions(content);

    const test = fs.readFileSync(hookTestFile, "utf-8");

    // Each exported function becomes a template entry, all pointing to same content
    for (const funcName of exportedFunctions) {
      templates.push({
        content,
        test,
        name: funcName,
      });
    }
  }

  // Sort alphabetically by name
  templates.sort((a, b) => a.name.localeCompare(b.name));

  return templates;
}

/**
 * Escape backticks and dollar signs for template literal embedding.
 */
function escapeTemplateString(content: string): string {
  return content
    .replace(/\\/g, "\\\\")
    .replace(/`/g, "\\`")
    .replace(/\$/g, "\\$");
}

/**
 * Generate the CLI template file content.
 */
function generateTemplateFileContent(templates: HookTemplate[]): string {
  const templateEntries = templates
    .map(({ content, name, test }) => {
      const escapedContent = escapeTemplateString(content);
      const escapedTest = escapeTemplateString(test);
      return `  ${name}: \`${escapedContent}\`,${name}_test: \`${escapedTest}\`,`;
    })
    .join("\n\n");

  return `// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
// Generated by: pnpm --filter @airyhooks/hooks build:templates
// Source: packages/hooks/src/*/use*.ts

export const templates: Record<string, string> = {
${templateEntries}
};
`;
}

/**
 * Main entry point.
 */
function main(): void {
  console.log("üîç Reading hook source files...");
  const templates = readHookTemplates();

  console.log(`üì¶ Found ${templates.length} hook exports:`);
  for (const { name } of templates) {
    console.log(`   - ${name}`);
  }

  console.log(`\nüìù Generating template file...`);
  const outputContent = generateTemplateFileContent(templates);

  // Ensure output directory exists
  const outputDir = path.dirname(CLI_OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(CLI_OUTPUT_PATH, outputContent, "utf-8");
  console.log(`‚úÖ Written to: ${CLI_OUTPUT_PATH}`);
}

main();
